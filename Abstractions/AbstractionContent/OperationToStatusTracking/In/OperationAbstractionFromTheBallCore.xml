<?xml version="1.0"?>
<OperationAbstraction xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://tempuri.org/Operation_v1_0.xsd">
  <Operations codeNamespace="TheBall.CORE">
    <Operation name="ImportAccountFromOIPLegacy">
      <OperationSpec>
        <Description>Imports account from OIP Legacy data</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="LegacyLogin" dataType="AaltoGlobalImpact.OIP.TBRLoginRoot" designDesc="Legacy login object" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="LegacyAccountRoot" asyncSupportMode="AsyncOnly" dataType="AaltoGlobalImpact.OIP.TBRAccountRoot" designDesc="Legacy account root" state="implemented">
            <Parameter name="LegacyLogin" />
          </TargetDefinition>
          <TargetDefinition name="LegacyAccount" dataType="AaltoGlobalImpact.OIP.TBAccount" designDesc="Legacy account" state="implemented">
            <Target name="LegacyAccountRoot" />
          </TargetDefinition>
          <TargetDefinition name="Account" asyncSupportMode="AsyncOnly" dataType="Account" designDesc="Account to be created; retrieved or created" state="implemented">
            <Target name="LegacyAccount" />
          </TargetDefinition>
          <MethodExecute name="AddMissingLogins" asyncSupportMode="AsyncOnly" designDesc="Add missing logins to account" state="implemented">
            <Target name="Account" />
            <Target name="LegacyAccount" />
          </MethodExecute>
          <MethodExecute name="AddMissingEmails" asyncSupportMode="AsyncOnly" designDesc="Add missing emails to account" state="implemented">
            <Target name="Account" />
            <Target name="LegacyAccount" />
          </MethodExecute>
          <MethodExecute name="StoreObject" asyncSupportMode="AsyncOnly" designDesc="Store object" state="implemented">
            <Target name="Account" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="ImportedAccount" dataType="Account" designDesc="Imported account" state="implemented" />
        <Target name="Account" />
      </OperationReturnValues>
    </Operation>
    <Operation name="EnsureLogin">
      <OperationSpec>
        <Description>Ensure login with given URL, if given accountID, ensure that its matching or none</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="LoginURL" dataType="string" designDesc="Login URL to fetch or create" state="implemented" />
        <Parameter name="AccountID" dataType="string" designDesc="(Optional) Account ID to require if the object is already existing and has any" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Login" asyncSupportMode="AsyncOnly" dataType="Login" designDesc="Login, created or fetched. Store object if it was created" state="implemented">
            <Parameter name="LoginURL" />
          </TargetDefinition>
          <MethodExecute name="ValidateExistingAccountIDToMatch" designDesc="Validate that existing account ID matches the given" state="implemented">
            <Parameter name="AccountID" />
            <Target name="Login" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="EnsuredLogin" dataType="Login" designDesc="Ensured login object" state="implemented" />
        <Target name="Login" />
      </OperationReturnValues>
    </Operation>
    <Operation name="ActivateEmailValidation">
      <OperationSpec>
        <Description>Activate email validation based on current time, (re)send validation code based on parameters</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Email" dataType="Email" designDesc="Email to confirm the validity for" state="implemented" />
        <Parameter name="SendValidationCodeIfReissued" dataType="bool" designDesc="Send validation email, if validation code is (re)issued" state="implemented" />
        <Parameter name="ResendValidationCode" dataType="bool" designDesc="Resend validation email even when the code wasn't reissued" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="ProcessEmailValidationActivation" asyncSupportMode="AsyncOnly" designDesc="Issue email validation if required, send the validation emails if required" state="implemented">
            <Parameter name="Email" />
            <Parameter name="SendValidationCodeIfReissued" />
            <Parameter name="ResendValidationCode" />
            <ReturnValue name="ValidationReissued" dataType="bool" designDesc="Reissued validation, needs to store Email object" state="implemented" />
          </MethodExecute>
          <MethodExecute name="StoreEmailIfChanged" asyncSupportMode="AsyncOnly" designDesc="Store Email object if changed due to revalidation" state="implemented">
            <Parameter name="Email" />
            <Target name="ProcessEmailValidationActivationOutput" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="EnsureEmail">
      <OperationSpec>
        <Description>Ensure email with given email address, if given accountID, ensure that its matching or none</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="EmailAddress" dataType="string" designDesc="Email address to fetch or create" state="implemented" />
        <Parameter name="AccountID" dataType="string" designDesc="(Optional) Account ID to require if the object is already existing and has any" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="ValidateEmailAddress" designDesc="Validate given email address, throw exception if not valid" state="implemented">
            <Parameter name="EmailAddress" />
          </MethodExecute>
          <TargetDefinition name="Email" asyncSupportMode="AsyncOnly" dataType="Email" designDesc="Email, created or fetched. Store object if it was created" state="implemented">
            <Parameter name="EmailAddress" />
          </TargetDefinition>
          <MethodExecute name="ValidateExistingAccountIDToMatch" designDesc="Validate that existing account ID matches the given" state="implemented">
            <Parameter name="AccountID" />
            <Target name="Email" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="EnsuredEmail" dataType="Email" designDesc="Ensured email object" state="implemented" />
        <Target name="Email" />
      </OperationReturnValues>
    </Operation>
    <Operation name="EnsureAccount">
      <OperationSpec>
        <Description>Connect to existing account or create new one based on email</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="LoginUrl" dataType="string" designDesc="Login url to be used to create the account" state="implemented" />
        <Parameter name="EmailAddress" dataType="string" designDesc="Email address" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <OperationExecute name="EnsureEmail" asyncSupportMode="AsyncOnly" targetOperationName="EnsureEmail" designDesc="Ensure email object defined for address" state="implemented">
            <Parameter name="EmailAddress" />
            <ReturnValue name="EnsuredEmail" dataType="Email" designDesc="Returned email" state="implemented" />
          </OperationExecute>
          <TargetDefinition name="ExistingAccount" asyncSupportMode="AsyncOnly" dataType="Account" designDesc="Existing account, if any" state="implemented">
            <Target name="EnsureEmailOutput" />
          </TargetDefinition>
          <TargetDefinition name="ResultingAccount" asyncSupportMode="AsyncOnly" dataType="Account" designDesc="Existing or newly created account, with email attached to it" state="implemented">
            <Parameter name="LoginUrl" />
            <Target name="EnsureEmailOutput" />
            <Target name="ExistingAccount" />
          </TargetDefinition>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="EnsuredAccount" dataType="Account" designDesc="Ensured account, with given email ensured and connected to it" state="implemented" />
        <Target name="ResultingAccount" />
      </OperationReturnValues>
    </Operation>
    <Operation name="CreateAccount">
      <OperationSpec>
        <Description>Create account with given login and email</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="AccountID" dataType="string" designDesc="AccountID (optional) to be created" state="implemented" />
        <Parameter name="LoginUrl" dataType="string" designDesc="Login url to be used to create the account" state="implemented" />
        <Parameter name="EmailAddress" dataType="string" designDesc="Email address to be used to create the account" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="AccountToBeCreated" dataType="Account" designDesc="Account object to be created" state="implemented">
            <Parameter name="AccountID" />
          </TargetDefinition>
          <OperationExecute name="Login" asyncSupportMode="AsyncOnly" targetOperationName="EnsureLogin" designDesc="Call operation to retrieve or create" state="implemented">
            <Parameter name="LoginUrl" />
            <Target name="AccountToBeCreated" />
            <ReturnValue name="Login" dataType="Login" designDesc="Login" state="implemented" />
          </OperationExecute>
          <OperationExecute name="Email" asyncSupportMode="AsyncOnly" targetOperationName="EnsureEmail" designDesc="Call operation to retrieve or create" state="implemented">
            <Parameter name="EmailAddress" />
            <Target name="AccountToBeCreated" />
            <ReturnValue name="Email" dataType="Email" designDesc="Email" state="implemented" />
          </OperationExecute>
          <MethodExecute name="ConnectLoginAndAccount" designDesc="Set account object ID to login and vice versa" state="implemented">
            <Target name="AccountToBeCreated" />
            <Target name="LoginOutput" />
          </MethodExecute>
          <MethodExecute name="ConnectEmailAndAccount" designDesc="Set account object ID to email and vice versa" state="implemented">
            <Target name="AccountToBeCreated" />
            <Target name="EmailOutput" />
          </MethodExecute>
          <MethodExecute name="StoreObjects" asyncSupportMode="AsyncOnly" designDesc="Store objects, account first then others that relate to it" state="implemented">
            <Target name="AccountToBeCreated" />
            <Target name="LoginOutput" />
            <Target name="EmailOutput" />
          </MethodExecute>
          <MethodExecute name="CopyAccountTemplates" asyncSupportMode="AsyncOnly" designDesc="Copy account web templates to newly created account" state="implemented">
            <Target name="AccountToBeCreated" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="CreatedAccount" dataType="Account" designDesc="Created account object" state="implemented" />
        <Target name="AccountToBeCreated" />
      </OperationReturnValues>
    </Operation>
    <Operation name="CreateGroup">
      <OperationSpec>
        <Description>Create group with optionally given ID</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="GroupID" dataType="string" designDesc="GroupID (optional) to be created" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="GroupToBeCreated" dataType="Group" designDesc="Group object to be created" state="implemented">
            <Parameter name="GroupID" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" asyncSupportMode="AsyncOnly" designDesc="Store object" state="implemented">
            <Target name="GroupToBeCreated" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="SetGroupMembership">
      <OperationSpec>
        <Description>Set group membership of an account</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="GroupID" dataType="string" designDesc="Group ID" state="implemented" />
        <Parameter name="AccountID" dataType="string" designDesc="Account ID" state="implemented" />
        <Parameter name="Role" dataType="string" designDesc="Role to set - null if to remove role entirely" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Account" asyncSupportMode="AsyncOnly" dataType="Account" designDesc="Account object" state="implemented">
            <Parameter name="AccountID" />
          </TargetDefinition>
          <TargetDefinition name="Group" asyncSupportMode="AsyncOnly" dataType="Group" designDesc="Group object" state="implemented">
            <Parameter name="GroupID" />
          </TargetDefinition>
          <TargetDefinition name="GroupMembership" asyncSupportMode="AsyncOnly" dataType="GroupMembership" designDesc="Get or create group membership for account and group" state="implemented">
            <Parameter name="AccountID" />
            <Parameter name="GroupID" />
          </TargetDefinition>
          <MethodExecute name="SetRoleToMembership" designDesc="Set account role to membership" state="implemented">
            <Parameter name="Role" />
            <Target name="GroupMembership" />
          </MethodExecute>
          <MethodExecute name="SetMembershipToGroup" designDesc="Set membership to group" state="implemented">
            <Target name="GroupMembership" />
            <Target name="Group" />
          </MethodExecute>
          <MethodExecute name="SetMembershipToAccount" designDesc="Set membership to account" state="implemented">
            <Target name="GroupMembership" />
            <Target name="Account" />
          </MethodExecute>
          <MethodExecute name="StoreObjects" asyncSupportMode="AsyncOnly" designDesc="Store objects" state="implemented">
            <Target name="GroupMembership" />
            <Target name="Group" />
            <Target name="Account" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="RemoveGroupMembership">
      <OperationSpec>
        <Description>Set group membership of an account</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="GroupID" dataType="string" designDesc="Group ID" state="implemented" />
        <Parameter name="AccountID" dataType="string" designDesc="Account ID" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Account" asyncSupportMode="AsyncOnly" dataType="Account" designDesc="Account object" state="implemented">
            <Parameter name="AccountID" />
          </TargetDefinition>
          <TargetDefinition name="Group" asyncSupportMode="AsyncOnly" dataType="Group" designDesc="Group object" state="implemented">
            <Parameter name="GroupID" />
          </TargetDefinition>
          <TargetDefinition name="GroupMembership" asyncSupportMode="AsyncOnly" dataType="GroupMembership" designDesc="Get or create group membership for account and group" state="implemented">
            <Parameter name="AccountID" />
            <Parameter name="GroupID" />
          </TargetDefinition>
          <MethodExecute name="RemoveMembershipFromGroup" designDesc="Remove membership from group" state="implemented">
            <Target name="GroupMembership" />
            <Target name="Group" />
          </MethodExecute>
          <MethodExecute name="RemoveMembershipFromAccount" designDesc="Remove membership from account" state="implemented">
            <Target name="GroupMembership" />
            <Target name="Account" />
          </MethodExecute>
          <MethodExecute name="StoreObjects" asyncSupportMode="AsyncOnly" designDesc="Store objects" state="implemented">
            <Target name="Group" />
            <Target name="Account" />
          </MethodExecute>
          <MethodExecute name="DeleteObject" asyncSupportMode="AsyncOnly" designDesc="Delete object" state="implemented">
            <Target name="GroupMembership" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="AddLoginToAccount">
      <OperationSpec>
        <Description />
      </OperationSpec>
      <Parameters>
        <Parameter name="AccountID" dataType="string" designDesc="Account ID" state="implemented" />
        <Parameter name="LoginUrl" dataType="string" designDesc="Login Url" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Account" asyncSupportMode="AsyncOnly" dataType="Account" designDesc="Account object" state="implemented">
            <Parameter name="AccountID" />
          </TargetDefinition>
          <TargetDefinition name="Login" asyncSupportMode="AsyncOnly" dataType="Login" designDesc="Login object" state="implemented">
            <Parameter name="LoginUrl" />
          </TargetDefinition>
          <MethodExecute name="AddLoginToAccount" designDesc="Add login object to account" state="implemented">
            <Target name="Account" />
            <Target name="Login" />
          </MethodExecute>
          <MethodExecute name="AddAccountToLogin" designDesc="Add account object to login" state="implemented">
            <Target name="Login" />
            <Target name="Account" />
          </MethodExecute>
          <MethodExecute name="StoreObjects" asyncSupportMode="AsyncOnly" designDesc="Store objects" state="implemented">
            <Target name="Account" />
            <Target name="Login" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="RemoveLogin">
      <OperationSpec>
        <Description>Remove login from system and from accounts</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="LoginUrl" dataType="string" designDesc="Login Url" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Login" asyncSupportMode="AsyncOnly" dataType="Login" designDesc="Login object" state="implemented">
            <Parameter name="LoginUrl" />
          </TargetDefinition>
          <TargetDefinition name="Account" asyncSupportMode="AsyncOnly" dataType="Account" designDesc="Account object" state="implemented">
            <Target name="Login" />
          </TargetDefinition>
          <MethodExecute name="RemoveLoginFromAccount" designDesc="Remove login from account" state="implemented">
            <Target name="Account" />
            <Target name="Login" />
          </MethodExecute>
          <MethodExecute name="DeleteObject" asyncSupportMode="AsyncOnly" designDesc="Delete object" state="implemented">
            <Target name="Login" />
          </MethodExecute>
          <MethodExecute name="StoreObject" asyncSupportMode="AsyncOnly" designDesc="Store object" state="implemented">
            <Target name="Account" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="AddEmailToAccount">
      <OperationSpec>
        <Description>Add email to account</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="AccountID" dataType="string" designDesc="Account ID" state="implemented" />
        <Parameter name="EmailAddress" dataType="string" designDesc="Email address" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Account" asyncSupportMode="AsyncOnly" dataType="Account" designDesc="Account object" state="implemented">
            <Parameter name="AccountID" />
          </TargetDefinition>
          <TargetDefinition name="Email" asyncSupportMode="AsyncOnly" dataType="Email" designDesc="Email object" state="implemented">
            <Parameter name="EmailAddress" />
          </TargetDefinition>
          <MethodExecute name="AddEmailToAccount" designDesc="Add email link to account" state="implemented">
            <Target name="Account" />
            <Target name="Email" />
          </MethodExecute>
          <MethodExecute name="AddAccountToEmail" designDesc="Add account link to email" state="implemented">
            <Target name="Email" />
            <Target name="Account" />
          </MethodExecute>
          <MethodExecute name="StoreObjects" asyncSupportMode="AsyncOnly" designDesc="Store objects" state="implemented">
            <Target name="Account" />
            <Target name="Email" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="RemoveEmail">
      <OperationSpec>
        <Description>Remove email object and link from account</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="EmailAddress" dataType="string" designDesc="Email address" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Email" asyncSupportMode="AsyncOnly" dataType="Email" designDesc="Email object" state="implemented">
            <Parameter name="EmailAddress" />
          </TargetDefinition>
          <TargetDefinition name="Account" asyncSupportMode="AsyncOnly" dataType="Account" designDesc="Account object" state="implemented">
            <Target name="Email" />
          </TargetDefinition>
          <MethodExecute name="RemoveEmailFromAccount" designDesc="Remove email link from account" state="implemented">
            <Target name="Account" />
            <Target name="Email" />
          </MethodExecute>
          <MethodExecute name="DeleteObject" asyncSupportMode="AsyncOnly" designDesc="Delete object" state="implemented">
            <Target name="Email" />
          </MethodExecute>
          <MethodExecute name="StoreObject" asyncSupportMode="AsyncOnly" designDesc="Store object" state="implemented">
            <Target name="Account" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="ObtainSystemProcessLock">
      <OperationSpec>
        <Description>Obtain system process lock for owner</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Container owner to obtain the lock for. Always obtain first on owner, then mark also to systemwide" state="implemented" />
        <Parameter name="LatestEntryTime" dataType="DateTime" designDesc="Latest locking entry timestamp" state="implemented" />
        <Parameter name="AmountOfEntries" dataType="int" designDesc="Amount of entries in the time of lock. Note! This is required to catch if new entries appear that have older times still!" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="LockFileContent" dataType="string" designDesc="Lock file text content" state="implemented">
            <Parameter name="LatestEntryTime" />
            <Parameter name="AmountOfEntries" />
          </TargetDefinition>
          <TargetDefinition name="OwnerLockFileName" dataType="string" designDesc="Lock file name" state="implemented" />
          <TargetDefinition name="SystemOwnerLockFileName" dataType="string" designDesc="Lock file name for system-owner lock" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="LatestEntryTime" />
          </TargetDefinition>
          <MethodExecute name="ObtainOwnerLevelLock" designDesc="Obtain owner level lock" state="implemented">
            <Parameter name="Owner" />
            <Target name="OwnerLockFileName" />
            <Target name="LockFileContent" />
            <ReturnValue name="ObtainedLockID" dataType="string" designDesc="If obtained succesfully, the locks ETag ID" state="implemented" />
          </MethodExecute>
          <MethodExecute name="ReportSystemLockToMatchOwnerLock" designDesc="Store system lock to match owner lock" state="implemented">
            <Target name="ObtainOwnerLevelLockOutput" />
            <Target name="SystemOwnerLockFileName" />
            <Target name="LockFileContent" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="ObtainedLockID" dataType="string" designDesc="If obtained succesfully, the locks ETag ID" state="implemented" />
        <Target name="ObtainOwnerLevelLockOutput" />
      </OperationReturnValues>
    </Operation>
    <Operation name="ReleaseSystemProcessLock">
      <OperationSpec>
        <Description>Release process lock for owner</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Container owner to obtain the lock for. Always obtain first on owner, then mark also to systemwide" state="implemented" />
        <Parameter name="LatestEntryTime" dataType="DateTime" designDesc="Latest locking entry timestamp" state="implemented" />
        <Parameter name="LockID" dataType="string" designDesc="Lock ID to release" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="OwnerLockFileName" dataType="string" designDesc="Lock file name" state="implemented" />
          <TargetDefinition name="SystemOwnerLockFileName" dataType="string" designDesc="Lock file name for system-owner lock" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="LatestEntryTime" />
          </TargetDefinition>
          <MethodExecute name="ReleaseOwnedOwnerLevelLock" designDesc="Obtain owner level lock" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="LockID" />
            <Target name="OwnerLockFileName" />
          </MethodExecute>
          <MethodExecute name="ReleaseReportingSystemLock" designDesc="Store system lock to match owner lock" state="implemented">
            <Target name="SystemOwnerLockFileName" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateProcess">
      <OperationSpec>
        <Description>
            Create process with initial parameters to set up
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="ProcessDescription" dataType="string" designDesc="Process description" state="implemented" />
        <Parameter name="ExecutingOperationName" dataType="string" designDesc="Execting operation name" state="implemented" />
        <Parameter name="InitialArguments" dataType="SemanticInformationItem[]" designDesc="Initial arguments as semantic information items" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Process" dataType="Process" designDesc="Create process object" state="implemented">
            <Parameter name="ProcessDescription" />
            <Parameter name="ExecutingOperationName" />
            <Parameter name="InitialArguments" />
          </TargetDefinition>
          <TargetDefinition name="OwnerProcessContainer" dataType="ProcessContainer" designDesc="Process container that contains all processes" state="implemented" />
          <MethodExecute name="AddProcessObjectToContainerAndStoreBoth" designDesc="Add process object to container and store both" state="implemented">
            <Target name="OwnerProcessContainer" />
            <Target name="Process" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="CreatedProcess" dataType="Process" designDesc="Created process" state="implemented" />
        <Target name="Process" />
      </OperationReturnValues>
    </Operation>
    <Operation name="DeleteProcess">
      <OperationSpec>
        <Description>
            Delete process and remove from OwnerProcessContainer
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="ProcessID" dataType="string" designDesc="Process ID of process to delete" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Process" dataType="Process" designDesc="Process to delete" state="implemented">
            <Parameter name="ProcessID" />
          </TargetDefinition>
          <TargetDefinition name="OwnerProcessContainer" dataType="ProcessContainer" designDesc="Process container that contains all processes" state="implemented" />
          <MethodExecute name="ObtainLockRemoveFromContainerAndDeleteProcess" designDesc="Remove process from container and delete process. NOTE! Obtain lock before delete process proceeding. If process is null already, remove ID if it's available in container." state="implemented">
            <Parameter name="ProcessID" />
            <Target name="Process" />
            <Target name="OwnerProcessContainer" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="ExecuteProcess">
      <OperationSpec>
        <Description>Executes proces with given ID</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="ProcessID" dataType="string" designDesc="Process ID" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="Process" dataType="TheBall.CORE.Process" designDesc="Process object of execution" state="implemented">
            <Parameter name="ProcessID" />
          </TargetDefinition>
          <TargetDefinition name="ProcessLockLocation" dataType="string" designDesc="Process lock file location" state="implemented">
            <Target name="Process" />
          </TargetDefinition>
          <MethodExecute name="ExecuteAndStoreProcessWithLock" designDesc="Execute process after obtaining lock, release lock afterwards - store process object if execution was performed. Don't do anything if lock was already there." state="implemented">
            <Target name="ProcessLockLocation" />
            <Target name="Process" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="SetObjectTreeValues">
      <OperationSpec>
        <Description>Set object tree values for root object and possible/optional ___ notation for tree-object property sets.</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="RootObject" dataType="IInformationObject" designDesc="Root object whose values (and tree) to set" state="implemented" />
        <Parameter name="HttpFormData" dataType="NameValueCollection" designDesc="HTTP POST data. Unprocessed and unfiltered." state="implemented" />
        <Parameter name="HttpFileData" dataType="System.Web.HttpFileCollection" designDesc="Http File data" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="CreateInternalObjects" designDesc="Create internal objects, whose values will be set after creation." state="implemented">
            <Parameter name="RootObject" />
            <Parameter name="HttpFormData" />
          </MethodExecute>
          <TargetDefinition name="FieldValues" dataType="NameValueCollection" designDesc="Filtered field value collection. Filter by non-prefix, add ID to keys. Reflect also to internal objects notation with ___ names texts." state="designApproved">
            <Parameter name="RootObject" />
            <Parameter name="HttpFormData" />
          </TargetDefinition>
          <MethodExecute name="DecodeEncodedRawHTMLValues" designDesc="Validate proper names of object types/field names and decode according to ENC. prefix" state="implemented">
            <Target name="FieldValues" />
          </MethodExecute>
          <TargetDefinition name="ObjectLinkValues" dataType="NameValueCollection" designDesc="Filtered object link value collection. Filter by Object_ prefix, add ID to keys." state="designApproved">
            <Parameter name="RootObject" />
            <Parameter name="HttpFormData" />
          </TargetDefinition>
          <TargetDefinition name="BinaryContentFiles" dataType="Dictionary&lt;string, MediaFileData&gt;" designDesc="Filtered binary content value collection. Filter by File_ prefix, add ID to keys." state="designApproved">
            <Parameter name="RootObject" />
            <Parameter name="HttpFormData" />
            <Parameter name="HttpFileData" />
          </TargetDefinition>
          <MethodExecute name="AddEncodedFormDataToBinaryFiles" designDesc="Add encoded form data to binary files" state="implemented">
            <Parameter name="RootObject" />
            <Parameter name="HttpFormData" />
            <Target name="BinaryContentFiles" />
          </MethodExecute>
          <MethodExecute name="SetFieldValues" designDesc="Set field values of created object." state="designApproved">
            <Parameter name="RootObject" />
            <Target name="FieldValues" />
          </MethodExecute>
          <MethodExecute name="SetObjectLinks" designDesc="Set object links of created object." state="designApproved">
            <Parameter name="RootObject" />
            <Target name="ObjectLinkValues" />
          </MethodExecute>
          <MethodExecute name="SetBinaryContent" designDesc="Sets binary content of created object." state="designApproved">
            <Parameter name="RootObject" />
            <Target name="BinaryContentFiles" />
          </MethodExecute>
          <MethodExecute name="StoreCompleteObject" designDesc="Stores the created object - with all set values." state="designApproved">
            <Parameter name="RootObject" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateSpecifiedInformationObjectWithValues">
      <OperationSpec>
        <Description>Creates information object, sets it values and stores it</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Object owner" state="designApproved" />
        <Parameter name="ObjectDomainName" dataType="string" designDesc="Object domain" state="designApproved" />
        <Parameter name="ObjectName" dataType="string" designDesc="Object name" state="designApproved" />
        <Parameter name="HttpFormData" dataType="NameValueCollection" designDesc="Http POST data. Unprocessed and unfiltered." state="implemented" />
        <Parameter name="HttpFileData" dataType="System.Web.HttpFileCollection" designDesc="Http File data" state="designApproved" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="CatchInvalidDomains" designDesc="Catch and throw an exception for invalid domains (system reserved)" state="implemented">
            <Parameter name="ObjectDomainName" />
          </MethodExecute>
          <TargetDefinition name="CreatedObject" dataType="IInformationObject" designDesc="Object that is created" state="designApproved">
            <Parameter name="Owner" />
            <Parameter name="ObjectDomainName" />
            <Parameter name="ObjectName" />
          </TargetDefinition>
          <MethodExecute name="StoreInitialObject" designDesc="Stores the object first time - with set values." state="designApproved">
            <Target name="CreatedObject" />
          </MethodExecute>
          <OperationExecute name="SetObjectValues" targetOperationName="SetObjectTreeValues" designDesc="Set object values and let the set operation to store the object." state="implemented">
            <Parameter name="HttpFormData" />
            <Parameter name="HttpFileData" />
            <Target name="CreatedObject" />
          </OperationExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="CreatedObjectResult" dataType="IInformationObject" designDesc="Created object as result" state="implemented" />
        <Target name="CreatedObject" />
      </OperationReturnValues>
    </Operation>
    <Operation name="DeleteSpecifiedInformationObject">
      <OperationSpec>
        <Description>
            Deletes specified information object.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Object owner" state="designApproved" />
        <Parameter name="ObjectDomainName" dataType="string" designDesc="Object domain" state="designApproved" />
        <Parameter name="ObjectName" dataType="string" designDesc="Object name" state="designApproved" />
        <Parameter name="ObjectID" dataType="string" designDesc="Object unique ID" state="designApproved" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="CatchInvalidDomains" designDesc="Catch and throw an exception for invalid domains (system reserved)" state="implemented">
            <Parameter name="ObjectDomainName" />
          </MethodExecute>
          <TargetDefinition name="ObjectToDelete" dataType="IInformationObject" designDesc="Object that is created" state="designApproved">
            <Parameter name="Owner" />
            <Parameter name="ObjectDomainName" />
            <Parameter name="ObjectName" />
            <Parameter name="ObjectID" />
          </TargetDefinition>
          <MethodExecute name="DeleteObject" designDesc="Delete the object." state="designApproved">
            <Target name="ObjectToDelete" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateDeviceMembership">
      <OperationSpec>
        <Description>
            Creates device membership for security context for owner.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="DeviceDescription" dataType="string" designDesc="Description of the device" state="implemented" />
        <Parameter name="ActiveSymmetricAESKey" dataType="byte[]" designDesc="Current active AES-256 key" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="CreatedDeviceMembership" dataType="DeviceMembership" designDesc="Created device membership" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="DeviceDescription" />
            <Parameter name="ActiveSymmetricAESKey" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store created object" state="implemented">
            <Target name="CreatedDeviceMembership" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="DeviceMembership" dataType="DeviceMembership" designDesc="Created device membership ID" state="implemented" />
        <Target name="CreatedDeviceMembership" />
      </OperationReturnValues>
    </Operation>
    <Operation name="SetDeviceMembershipValidationAndActiveStatus">
      <OperationSpec>
        <Description>
            Set device membership validation.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="DeviceMembershipID" dataType="string" designDesc="ID of device membership" state="implemented" />
        <Parameter name="IsValidAndActive" dataType="bool" designDesc="Value for validated and active" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="DeviceMembership" dataType="DeviceMembership" designDesc="Created device membership" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="DeviceMembershipID" />
          </TargetDefinition>
          <MethodExecute name="SetDeviceValidAndActiveValue" designDesc="Set device valid and active value" state="implemented">
            <Parameter name="IsValidAndActive" />
            <Target name="DeviceMembership" />
          </MethodExecute>
          <MethodExecute name="StoreObject" designDesc="Store created object" state="implemented">
            <Target name="DeviceMembership" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="DeleteDeviceMembership">
      <OperationSpec>
        <Description>
            Delete device membership record entirely.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="DeviceMembershipID" dataType="string" designDesc="ID of device membership" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="DeviceMembership" dataType="DeviceMembership" designDesc="Created device membership" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="DeviceMembershipID" />
          </TargetDefinition>
          <MethodExecute name="DeleteDeviceMembership" designDesc="Delete device membership record" state="implemented">
            <Target name="DeviceMembership" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateAndSendEmailValidationForDeviceJoinConfirmation">
      <OperationSpec>
        <Description>
            Creates and sends email validation for device join confirmation.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="OwningAccount" dataType="AaltoGlobalImpact.OIP.TBAccount" designDesc="Security context owner - if an account" state="implemented" />
        <Parameter name="OwningGroup" dataType="AaltoGlobalImpact.OIP.TBCollaboratingGroup" designDesc="Security context owner - if a group" state="implemented" />
        <Parameter name="DeviceMembership" dataType="DeviceMembership" designDesc="Device membership" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="OwnerEmailAddresses" dataType="string[]" designDesc="Owner relevant email address(es). For group - the initiator's active group email, for account - all of accounts emails" state="implemented">
            <Parameter name="OwningAccount" />
            <Parameter name="OwningGroup" />
          </TargetDefinition>
          <TargetDefinition name="EmailValidation" dataType="AaltoGlobalImpact.OIP.TBEmailValidation" designDesc="Email validation item for 30 minutes" state="implemented">
            <Parameter name="OwningAccount" />
            <Parameter name="OwningGroup" />
            <Parameter name="DeviceMembership" />
            <Target name="OwnerEmailAddresses" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store email validation object" state="implemented">
            <Target name="EmailValidation" />
          </MethodExecute>
          <MethodExecute name="SendEmailConfirmation" designDesc="Create and send email confirmation for joining the devices" state="implemented">
            <Parameter name="DeviceMembership" />
            <Target name="EmailValidation" />
            <Target name="OwnerEmailAddresses" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateAuthenticatedAsActiveDevice">
      <OperationSpec>
        <Description>
            Creates device membership FROM the group as authenticated against other group.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="AuthenticationDeviceDescription" dataType="string" designDesc="Description of the device" state="implemented" />
        <Parameter name="TargetBallHostName" dataType="string" designDesc="Target Ball instance host name. If not given, using the same host that the call was made from." state="implemented" />
        <Parameter name="TargetGroupID" dataType="string" designDesc="Target group ID to which the device membership is established" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="NegotiationURL" dataType="string" designDesc="Trust negotiation URL" state="implemented">
            <Parameter name="TargetBallHostName" />
            <Parameter name="TargetGroupID" />
          </TargetDefinition>
          <TargetDefinition name="ConnectionURL" dataType="string" designDesc="Established connection URL" state="implemented">
            <Parameter name="TargetBallHostName" />
            <Parameter name="TargetGroupID" />
          </TargetDefinition>
          <TargetDefinition name="AuthenticatedAsActiveDevice" dataType="AuthenticatedAsActiveDevice" designDesc="Created device membership client" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="AuthenticationDeviceDescription" />
            <Target name="NegotiationURL" />
            <Target name="ConnectionURL" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store created object" state="implemented">
            <Target name="AuthenticatedAsActiveDevice" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="CreatedAuthenticatedAsActiveDevice" dataType="AuthenticatedAsActiveDevice" designDesc="Created device client membership" state="implemented" />
        <Target name="AuthenticatedAsActiveDevice" />
      </OperationReturnValues>
    </Operation>
    <Operation name="PerformNegotiationAndValidateAuthenticationAsActiveDevice">
      <OperationSpec>
        <Description>
            Negotiate and validate authentication as active device.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="AuthenticatedAsActiveDeviceID" dataType="string" designDesc="ID of device membership" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="AuthenticatedAsActiveDevice" dataType="AuthenticatedAsActiveDevice" designDesc="Created device membership" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="AuthenticatedAsActiveDeviceID" />
          </TargetDefinition>
          <TargetDefinition name="RemoteBallSecretRequestUrl" dataType="string" designDesc="Remote Ball secret request url" state="implemented">
            <Target name="AuthenticatedAsActiveDevice" />
          </TargetDefinition>
          <TargetDefinition name="SharedSecretFullPayload" dataType="byte[]" designDesc="Obtain shared secret payload through SSL call from remote" state="implemented">
            <Target name="RemoteBallSecretRequestUrl" />
          </TargetDefinition>
          <TargetDefinition name="SharedSecretData" dataType="byte[]" designDesc="Extracted shared secret data from full payload" state="implemented">
            <Target name="SharedSecretFullPayload" />
          </TargetDefinition>
          <TargetDefinition name="SharedSecretPayload" dataType="byte[]" designDesc="Extracted shared secret payload from full payload" state="implemented">
            <Target name="SharedSecretFullPayload" />
          </TargetDefinition>
          <MethodExecute name="NegotiateWithTarget" designDesc="Negotiate with target party. Set validation flag as true if succesfully negotiated." state="implemented">
            <Target name="AuthenticatedAsActiveDevice" />
            <Target name="SharedSecretData" />
            <Target name="SharedSecretPayload" />
          </MethodExecute>
          <MethodExecute name="StoreObject" designDesc="Store created object" state="implemented">
            <Target name="AuthenticatedAsActiveDevice" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="DeleteAuthenticatedAsActiveDevice">
      <OperationSpec>
        <Description>
            Delete device membership record entirely.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="AuthenticatedAsActiveDeviceID" dataType="string" designDesc="ID of device membership" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="AuthenticatedAsActiveDevice" dataType="AuthenticatedAsActiveDevice" designDesc="Created device membership" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="AuthenticatedAsActiveDeviceID" />
          </TargetDefinition>
          <MethodExecute name="CallDeleteDeviceOnRemoteSide" designDesc="Call delete device on remote side of device connection" state="implemented">
            <Target name="AuthenticatedAsActiveDevice" />
          </MethodExecute>
          <MethodExecute name="DeleteAuthenticatedAsActiveDevice" designDesc="Delete device membership record" state="implemented">
            <Target name="AuthenticatedAsActiveDevice" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateInformationOutput">
      <OperationSpec>
        <Description>
            Creates information output for security context for owner.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="OutputDescription" dataType="string" designDesc="Description of the information output" state="implemented" />
        <Parameter name="DestinationURL" dataType="string" designDesc="Information target location URL" state="implemented" />
        <Parameter name="DestinationContentName" dataType="string" designDesc="Destionation content name" state="implemented" />
        <Parameter name="LocalContentURL" dataType="string" designDesc="Local content URL" state="implemented" />
        <Parameter name="AuthenticatedDeviceID" dataType="string" designDesc="Authenticated device ID for this connection (optional)" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="CreatedInformationOutput" dataType="InformationOutput" designDesc="Created information output" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="OutputDescription" />
            <Parameter name="DestinationURL" />
            <Parameter name="DestinationContentName" />
            <Parameter name="LocalContentURL" />
            <Parameter name="AuthenticatedDeviceID" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store created object" state="implemented">
            <Target name="CreatedInformationOutput" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="InformationOutput" dataType="InformationOutput" designDesc="Created information output" state="implemented" />
        <Target name="CreatedInformationOutput" />
      </OperationReturnValues>
    </Operation>
    <Operation name="SetInformationOutputValidationAndActiveStatus">
      <OperationSpec>
        <Description>
            Set information output validation and active-statuses.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="InformationOutputID" dataType="string" designDesc="ID of information output" state="implemented" />
        <Parameter name="IsValidAndActive" dataType="bool" designDesc="Value for validated and active" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="InformationOutput" dataType="InformationOutput" designDesc="Information output of which to set the status" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="InformationOutputID" />
          </TargetDefinition>
          <MethodExecute name="SetInputValidAndActiveValue" designDesc="Set input valid and active value" state="implemented">
            <Parameter name="IsValidAndActive" />
            <Target name="InformationOutput" />
          </MethodExecute>
          <MethodExecute name="StoreObject" designDesc="Store modified object" state="implemented">
            <Target name="InformationOutput" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="DeleteInformationOutput">
      <OperationSpec>
        <Description>
            Delete information input source.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="InformationOutputID" dataType="string" designDesc="ID of information output" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="InformationOutput" dataType="InformationOutput" designDesc="Information output to delete" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="InformationOutputID" />
          </TargetDefinition>
          <MethodExecute name="DeleteInformationOutput" designDesc="Delete information output record" state="implemented">
            <Target name="InformationOutput" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateAndSendEmailValidationForInformationOutputConfirmation">
      <OperationSpec>
        <Description>
            Creates and sends email validation for information output confirmation.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="OwningAccount" dataType="AaltoGlobalImpact.OIP.TBAccount" designDesc="Security context owner - if an account" state="implemented" />
        <Parameter name="OwningGroup" dataType="AaltoGlobalImpact.OIP.TBCollaboratingGroup" designDesc="Security context owner - if a group" state="implemented" />
        <Parameter name="InformationOutput" dataType="InformationOutput" designDesc="Information output" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="OwnerEmailAddresses" dataType="string[]" designDesc="Owner relevant email address(es). For group - the initiator's active group email, for account - all of accounts emails" state="implemented">
            <Parameter name="OwningAccount" />
            <Parameter name="OwningGroup" />
          </TargetDefinition>
          <TargetDefinition name="EmailValidation" dataType="AaltoGlobalImpact.OIP.TBEmailValidation" designDesc="Email validation item for 30 minutes" state="implemented">
            <Parameter name="OwningAccount" />
            <Parameter name="OwningGroup" />
            <Parameter name="InformationOutput" />
            <Target name="OwnerEmailAddresses" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store email validation object" state="implemented">
            <Target name="EmailValidation" />
          </MethodExecute>
          <MethodExecute name="SendEmailConfirmation" designDesc="Create and send email confirmation for approving information output" state="implemented">
            <Parameter name="InformationOutput" />
            <Target name="EmailValidation" />
            <Target name="OwnerEmailAddresses" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="PushToInformationOutput">
      <OperationSpec>
        <Description>
            Push information output to given target
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="InformationOutputID" dataType="string" designDesc="ID of information output" state="implemented" />
        <Parameter name="LocalContentName" dataType="string" designDesc="Required of LocalContentURL ends with /" state="implemented" />
        <Parameter name="SpecificDestinationContentName" dataType="string" designDesc="Optional dedicated content name - if given." state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="InformationOutput" dataType="InformationOutput" designDesc="Information output to push the data to" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="InformationOutputID" />
          </TargetDefinition>
          <MethodExecute name="VerifyValidOutput" designDesc="Verify that output is valid and active" state="implemented">
            <Target name="InformationOutput" />
          </MethodExecute>
          <TargetDefinition name="DestinationURL" dataType="string" designDesc="Location to push the output to" state="implemented">
            <Target name="InformationOutput" />
          </TargetDefinition>
          <TargetDefinition name="DestinationContentName" dataType="string" designDesc="Destination content name" state="implemented">
            <Parameter name="SpecificDestinationContentName" />
            <Target name="InformationOutput" />
          </TargetDefinition>
          <TargetDefinition name="LocalContentURL" dataType="string" designDesc="Local content URL to push the output from" state="implemented">
            <Parameter name="LocalContentName" />
            <Target name="InformationOutput" />
          </TargetDefinition>
          <TargetDefinition name="AuthenticatedAsActiveDevice" dataType="AuthenticatedAsActiveDevice" designDesc="Authenticated as device info (if available)" state="implemented">
            <Target name="InformationOutput" />
          </TargetDefinition>
          <MethodExecute name="PushToInformationOutput" designDesc="Push information to output" state="implemented">
            <Parameter name="Owner" />
            <Target name="InformationOutput" />
            <Target name="DestinationURL" />
            <Target name="DestinationContentName" />
            <Target name="LocalContentURL" />
            <Target name="AuthenticatedAsActiveDevice" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateInformationInput">
      <OperationSpec>
        <Description>
            Creates information input for security context for owner.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="InputDescription" dataType="string" designDesc="Description of the information input" state="implemented" />
        <Parameter name="LocationURL" dataType="string" designDesc="Information source location URL" state="implemented" />
        <Parameter name="LocalContentName" dataType="string" designDesc="Local content name" state="implemented" />
        <Parameter name="AuthenticatedDeviceID" dataType="string" designDesc="Authenticated device ID for this connection (optional)" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="CreatedInformationInput" dataType="InformationInput" designDesc="Created information input" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="InputDescription" />
            <Parameter name="LocationURL" />
            <Parameter name="LocalContentName" />
            <Parameter name="AuthenticatedDeviceID" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store created object" state="implemented">
            <Target name="CreatedInformationInput" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="InformationInput" dataType="InformationInput" designDesc="Created information input" state="implemented" />
        <Target name="CreatedInformationInput" />
      </OperationReturnValues>
    </Operation>
    <Operation name="SetInformationInputValidationAndActiveStatus">
      <OperationSpec>
        <Description>
            Set information input validation and active-statuses.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="InformationInputID" dataType="string" designDesc="ID of information input" state="implemented" />
        <Parameter name="IsValidAndActive" dataType="bool" designDesc="Value for validated and active" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="InformationInput" dataType="InformationInput" designDesc="Information input of which to set the status" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="InformationInputID" />
          </TargetDefinition>
          <MethodExecute name="SetInputValidAndActiveValue" designDesc="Set input valid and active value" state="implemented">
            <Parameter name="IsValidAndActive" />
            <Target name="InformationInput" />
          </MethodExecute>
          <MethodExecute name="StoreObject" designDesc="Store created object" state="implemented">
            <Target name="InformationInput" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="DeleteInformationInput">
      <OperationSpec>
        <Description>
            Delete information input source.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="InformationInputID" dataType="string" designDesc="ID of device membership" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="InformationInput" dataType="InformationInput" designDesc="Information input to delete" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="InformationInputID" />
          </TargetDefinition>
          <MethodExecute name="DeleteInformationInput" designDesc="Delete information input record" state="implemented">
            <Target name="InformationInput" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateAndSendEmailValidationForInformationInputConfirmation">
      <OperationSpec>
        <Description>
            Creates and sends email validation for information input confirmation.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="OwningAccount" dataType="AaltoGlobalImpact.OIP.TBAccount" designDesc="Security context owner - if an account" state="implemented" />
        <Parameter name="OwningGroup" dataType="AaltoGlobalImpact.OIP.TBCollaboratingGroup" designDesc="Security context owner - if a group" state="implemented" />
        <Parameter name="InformationInput" dataType="InformationInput" designDesc="Information input" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="OwnerEmailAddresses" dataType="string[]" designDesc="Owner relevant email address(es). For group - the initiator's active group email, for account - all of accounts emails" state="implemented">
            <Parameter name="OwningAccount" />
            <Parameter name="OwningGroup" />
          </TargetDefinition>
          <TargetDefinition name="EmailValidation" dataType="AaltoGlobalImpact.OIP.TBEmailValidation" designDesc="Email validation item for 30 minutes" state="implemented">
            <Parameter name="OwningAccount" />
            <Parameter name="OwningGroup" />
            <Parameter name="InformationInput" />
            <Target name="OwnerEmailAddresses" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store email validation object" state="implemented">
            <Target name="EmailValidation" />
          </MethodExecute>
          <MethodExecute name="SendEmailConfirmation" designDesc="Create and send email confirmation for joining the devices" state="implemented">
            <Parameter name="InformationInput" />
            <Target name="EmailValidation" />
            <Target name="OwnerEmailAddresses" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="JoinAccountToGroup">
      <OperationSpec>
        <Description>Joins user to group with given membership level</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="AccountEmailAddress" dataType="string" designDesc="Email address of an account" state="implemented" />
        <Parameter name="GroupID" dataType="string" designDesc="Group ID to join to" state="implemented" />
        <Parameter name="MemberRole" dataType="string" designDesc="Role of group" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="JoinAccountToGroup" designDesc="Join account to group using AGI namespace operations in chain" state="implemented">
            <Parameter name="AccountEmailAddress" />
            <Parameter name="GroupID" />
            <Parameter name="MemberRole" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="RemoveAccountFromGroup">
      <OperationSpec>
        <Description>Remove account from group</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="AccountEmailAddress" dataType="string" designDesc="Email address of an account" state="implemented" />
        <Parameter name="AccountID" dataType="string" designDesc="Account ID to remove" state="implemented" />
        <Parameter name="GroupID" dataType="string" designDesc="Group ID to remove from" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="RemoveAccountFromGroup" designDesc="Remove account from group using AGI namespace operation(s)" state="implemented">
            <Parameter name="AccountEmailAddress" />
            <Parameter name="AccountID" />
            <Parameter name="GroupID" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="FetchInputInformation">
      <OperationSpec>
        <Description>
            Fetch input information from given source
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="InformationInputID" dataType="string" designDesc="ID of information input" state="implemented" />
        <Parameter name="QueryParameters" dataType="string" designDesc="URL query parameters" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="InformationInput" dataType="InformationInput" designDesc="Information input to fetch the data for" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="InformationInputID" />
          </TargetDefinition>
          <MethodExecute name="VerifyValidInput" designDesc="Verify that input is valid and active" state="implemented">
            <Target name="InformationInput" />
          </MethodExecute>
          <TargetDefinition name="InputFetchLocation" dataType="string" designDesc="Location to fetch the input into" state="implemented">
            <Target name="InformationInput" />
          </TargetDefinition>
          <TargetDefinition name="InputFetchName" dataType="string" designDesc="Name of item to store the fetched input - derived from local content name." state="implemented">
            <Target name="InformationInput" />
          </TargetDefinition>
          <TargetDefinition name="AuthenticatedAsActiveDevice" dataType="AuthenticatedAsActiveDevice" designDesc="Authenticated as device info (if available)" state="implemented">
            <Target name="InformationInput" />
          </TargetDefinition>
          <MethodExecute name="FetchInputToStorage" designDesc="Fetch input to storage" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="QueryParameters" />
            <Target name="InformationInput" />
            <Target name="InputFetchLocation" />
            <Target name="InputFetchName" />
            <Target name="AuthenticatedAsActiveDevice" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="ProcessFetchedInputs">
      <OperationSpec>
        <Description>
            Process fetched inputs
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Security context owner" state="implemented" />
        <Parameter name="InformationInputID" dataType="string" designDesc="ID of information input" state="implemented" />
        <Parameter name="ProcessingOperationName" dataType="string" designDesc="Processing operation name" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="InformationInput" dataType="InformationInput" designDesc="Information input to fetch the data for" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="InformationInputID" />
          </TargetDefinition>
          <MethodExecute name="VerifyValidInput" designDesc="Verify that input is valid and active" state="implemented">
            <Target name="InformationInput" />
          </MethodExecute>
          <TargetDefinition name="InputFetchLocation" dataType="string" designDesc="Location to fetch the input into" state="implemented">
            <Target name="InformationInput" />
          </TargetDefinition>
          <MethodExecute name="ProcessInputFromStorage" designDesc="Process input from storage" state="implemented">
            <Parameter name="ProcessingOperationName" />
            <Target name="InformationInput" />
            <Target name="InputFetchLocation" />
            <ReturnValue name="ProcessingResultsToStore" dataType="IInformationObject[]" designDesc="Information objects to store as result of processing" state="implemented" />
            <ReturnValue name="ProcessingResultsToDelete" dataType="IInformationObject[]" designDesc="Information objects to delete as result of processing" state="implemented" />
          </MethodExecute>
          <MethodExecute name="StoreObjects" designDesc="Store processed objects" state="implemented">
            <Target name="ProcessInputFromStorageOutput.ProcessingResultsToStore" />
          </MethodExecute>
          <MethodExecute name="DeleteObjects" designDesc="Delete obsolete processed objects" state="implemented">
            <Target name="ProcessInputFromStorageOutput.ProcessingResultsToDelete" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="BeginAccountEmailAddressRegistration">
      <OperationSpec>
        <Description>
            Begins account email address registration. Registration needs to be confimed by clicking the email validation link that is sent to email to be registered.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="AccountID" dataType="string" designDesc="AccountID whose email is to be registered" state="implemented" />
        <Parameter name="EmailAddress" dataType="string" designDesc="Email address to add to account" state="implemented" />
        <Parameter name="RedirectUrlAfterValidation" dataType="string" designDesc="Redirect url after email validation" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="ValidateUnexistingEmail" designDesc="Validate that the email to add is not already registered" state="implemented">
            <Parameter name="EmailAddress" />
          </MethodExecute>
          <TargetDefinition name="EmailValidation" dataType="AaltoGlobalImpact.OIP.TBEmailValidation" designDesc="Email validation object prepared ready to stored and to be sent" state="implemented">
            <Parameter name="AccountID" />
            <Parameter name="EmailAddress" />
            <Parameter name="RedirectUrlAfterValidation" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store processed objects" state="implemented">
            <Target name="EmailValidation" />
          </MethodExecute>
          <MethodExecute name="SendEmailConfirmation" designDesc="Create and send email confirmation for validating the email" state="implemented">
            <Target name="EmailValidation" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="RegisterEmailAddress">
      <OperationSpec>
        <Description>
            Registers email address to account. 
            It is called at email address validator (confirming the email), but also with verified-cookie based email, when account is freshly created.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="AccountID" dataType="string" designDesc="Account whose email is to be registered" state="implemented" />
        <Parameter name="EmailAddress" dataType="string" designDesc="Email address to add to account" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="ValidateUnexistingEmail" designDesc="Validate that the email to add is not already registered" state="implemented">
            <Parameter name="EmailAddress" />
          </MethodExecute>
          <TargetDefinition name="AccountRoot" dataType="AaltoGlobalImpact.OIP.TBRAccountRoot" designDesc="Account object" state="implemented">
            <Parameter name="AccountID" />
          </TargetDefinition>
          <TargetDefinition name="EmailRoot" dataType="AaltoGlobalImpact.OIP.TBREmailRoot" designDesc="Email root object" state="implemented">
            <Parameter name="EmailAddress" />
          </TargetDefinition>
          <MethodExecute name="AddEmailToAccount" designDesc="Add email object to accounts email collection" state="implemented">
            <Parameter name="EmailAddress" />
            <Target name="AccountRoot" />
          </MethodExecute>
          <MethodExecute name="AddAccountToEmailRoot" designDesc="Add account object to email root" state="implemented">
            <Target name="AccountRoot" />
            <Target name="EmailRoot" />
          </MethodExecute>
          <MethodExecute name="StoreEmailRoot" designDesc="Store email root object FIRST to confirm that this email was first bound to this registration." state="implemented">
            <Target name="EmailRoot" />
          </MethodExecute>
          <MethodExecute name="StoreAccountRoot" designDesc="Store account root" state="implemented">
            <Target name="AccountRoot" />
          </MethodExecute>
          <MethodExecute name="UpdateAccountRootAndContainerWithChanges" designDesc="Update account root and container objects with changes" state="implemented">
            <Parameter name="AccountID" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="UnregisterEmailAddress">
      <OperationSpec>
        <Description>
              Begins account email address registration. Registration needs to be confimed by clicking the email validation link that is sent to email to be registered.
            </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="AccountID" dataType="string" designDesc="AccountID whose email is to be registered" state="implemented" />
        <Parameter name="EmailAddress" dataType="string" designDesc="Email address to add to account" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="AccountContainerBeforeGroupRemoval" dataType="AaltoGlobalImpact.OIP.AccountContainer" designDesc="AccountContainer of account" state="designApproved">
            <Parameter name="AccountID" />
          </TargetDefinition>
          <TargetDefinition name="EmailAddressID" dataType="string" designDesc="Email Address ID within AccountContainer" state="designApproved">
            <Parameter name="EmailAddress" />
            <Target name="AccountContainerBeforeGroupRemoval" />
          </TargetDefinition>
          <MethodExecute name="ExecuteUnlinkEmailAddress" designDesc="Perform unlink" state="designApproved">
            <Parameter name="AccountID" />
            <Target name="AccountContainerBeforeGroupRemoval" />
            <Target name="EmailAddressID" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="InitiateImportedGroupWithUnchangedID">
      <OperationSpec>
        <Description>Initiate imported group. NOTE! The ID needs to remain the same. Group contains internal structures.</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="GroupID" dataType="string" designDesc="Group ID to be initiated" state="implemented" />
        <Parameter name="InitiatorAccountID" dataType="string" designDesc="Account ID of initiator" state="implemented" />
        <Parameter name="TemplateNameList" dataType="string" designDesc="Comma separated list of templates to initialize group" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="GroupAsOwner" dataType="TheBall.CORE.IContainerOwner" designDesc="Container owner" state="implemented">
            <Parameter name="GroupID" />
          </TargetDefinition>
          <TargetDefinition name="GroupContainer" dataType="AaltoGlobalImpact.OIP.GroupContainer" designDesc="Group container" state="implemented">
            <Target name="GroupAsOwner" />
          </TargetDefinition>
          <MethodExecute name="ValidateGroupContainerID" designDesc="Validate group container ID, so that it matches the referencing ID" state="implemented">
            <Parameter name="GroupID" />
            <Target name="GroupContainer" />
          </MethodExecute>
          <TargetDefinition name="GroupRoot" dataType="AaltoGlobalImpact.OIP.TBRGroupRoot" designDesc="Group root item to match the group" state="implemented">
            <Parameter name="GroupID" />
          </TargetDefinition>
          <MethodExecute name="StoreObjects" designDesc="Store objects" state="implemented">
            <Target name="GroupRoot" />
            <Target name="GroupContainer" />
          </MethodExecute>
          <MethodExecute name="SetGroupInitiatorAccess" designDesc="Set group access as initiator only" state="implemented">
            <Target name="GroupRoot" />
            <Target name="GroupContainer" />
          </MethodExecute>
          <MethodExecute name="FixContentTypesAndMetadataOfBlobs" designDesc="Fix content types and metadata of blobs" state="implemented">
            <Target name="GroupAsOwner" />
          </MethodExecute>
          <MethodExecute name="FixRelativeLocationsOfInformationObjects" designDesc="Fix relative locations of objects" state="implemented">
            <Target name="GroupAsOwner" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="UpdateTemplateForAllGroups">
      <OperationSpec>
        <Description>Update given template for all groups</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="TemplateName" dataType="string" designDesc="Template name" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="GroupLocations" asyncSupportMode="AsyncOnly" dataType="string[]" designDesc="All group locations" state="implemented" />
          <MethodExecute name="CallUpdateOwnerTemplates" asyncSupportMode="AsyncOnly" designDesc="Call UpdateContainerOwnerTemplates for each" state="implemented">
            <Parameter name="TemplateName" />
            <Target name="GroupLocations" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="UpdateTemplateForAllAccounts">
      <OperationSpec>
        <Description>Update given template for all accounts</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="TemplateName" dataType="string" designDesc="Template name" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="AccountLocations" asyncSupportMode="AsyncOnly" dataType="string[]" designDesc="All account locations" state="implemented" />
          <MethodExecute name="CallUpdateOwnerTemplates" asyncSupportMode="AsyncOnly" designDesc="Call UpdateContainerOwnerTemplates for each" state="implemented">
            <Parameter name="TemplateName" />
            <Target name="AccountLocations" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="UpdateContainerOwnerTemplates">
      <OperationSpec>
        <Description>Update container owner templates from system template location</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="OwnerRootLocation" dataType="string" designDesc="Owner root location" state="implemented" />
        <Parameter name="TemplateName" dataType="string" designDesc="Template name to update" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="TargetOwner" dataType="IContainerOwner" designDesc="Target owner" state="implemented">
            <Parameter name="OwnerRootLocation" />
          </TargetDefinition>
          <MethodExecute name="ValidateTargetIsAccountOrGroup" asyncSupportMode="AsyncOnly" designDesc="Validate the owner is either account or group" state="implemented">
            <Target name="TargetOwner" />
          </MethodExecute>
          <MethodExecute name="ValidateTemplateName" designDesc="Validate template name is valid, not containing dot, not empty" state="implemented">
            <Parameter name="TemplateName" />
          </MethodExecute>
          <TargetDefinition name="SystemTemplateSource" dataType="string" designDesc="System template source based on target owner type" state="implemented">
            <Target name="TargetOwner" />
          </TargetDefinition>
          <TargetDefinition name="TemplateSourceLocation" dataType="string" designDesc="Template source location from system template location" state="implemented">
            <Parameter name="TemplateName" />
            <Target name="SystemTemplateSource" />
          </TargetDefinition>
          <TargetDefinition name="TemplateTargetLocation" dataType="string" designDesc="Template target location on target owner storage" state="implemented">
            <Parameter name="TemplateName" />
            <Target name="TargetOwner" />
          </TargetDefinition>
          <MethodExecute name="SyncTemplateContent" asyncSupportMode="AsyncOnly" designDesc="Sync template content from source to target" state="implemented">
            <Target name="TemplateSourceLocation" />
            <Target name="TemplateTargetLocation" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="SetOwnerWebRedirect">
      <OperationSpec>
        <Description>
            Sets owner web redirect. Stores a text file in owner folder with redirector-specific name. Might support parameters and multiple files later on.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Owner whose redirection is to be set" state="implemented" />
        <Parameter name="RedirectPath" dataType="string" designDesc="Redirect path, if null or empty, the redirection is to be removed." state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="SetRedirection" designDesc="Sets the redirection file for owner." state="implemented">
            <Parameter name="Owner" />
            <Parameter name="RedirectPath" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="ProcessAllResourceUsagesToOwnerCollections">
      <OperationSpec>
        <Description>Process all request usage records to owner collections. Call repeatedly proper batch processing operation(s). Break if operation doesn't process for any reason, such as failing to acquire lock.</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="ProcessBatchSize" dataType="int" designDesc="Batch size to process as a block." state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="ExecuteBatchProcessor" designDesc="Execute batch processor with given batch size until there are less than batch size left" state="implemented">
            <Parameter name="ProcessBatchSize" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="ProcessBatchOfResourceUsagesToOwnerCollections">
      <OperationSpec>
        <Description>Process request usage records to owner collections. Process given amount at a time, acquire lock to allow parallel launches. Don't process if the minimum number is not met.</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="ProcessBatchSize" dataType="int" designDesc="Batch size to process as a block." state="implemented" />
        <Parameter name="ProcessIfLess" dataType="bool" designDesc="Process if less than requested size" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="BatchToProcess" dataType="Microsoft.WindowsAzure.Storage.Blob.CloudBlockBlob[]" designDesc="Retrieve block blob list to process - and acquire lock if possible. Null if doesn't match requirement or fail to acquire lock" state="implemented">
            <Parameter name="ProcessBatchSize" />
            <Parameter name="ProcessIfLess" />
          </TargetDefinition>
          <MethodExecute name="ProcessBatch" designDesc="Process batch if not null." state="implemented">
            <Target name="BatchToProcess" />
          </MethodExecute>
          <MethodExecute name="DeleteProcessedItems" designDesc="Delete processed blobs" state="implemented">
            <Target name="BatchToProcess" />
          </MethodExecute>
          <MethodExecute name="ReleaseLock" designDesc="Release lock if acquired" state="implemented">
            <Target name="BatchToProcess" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="ProcessedAnything" dataType="bool" designDesc="Did the operation process anything" state="implemented" />
        <ReturnValue name="ProcessedFullCount" dataType="bool" designDesc="Did the operation have full batch size to process" state="implemented" />
        <Parameter name="ProcessBatchSize" />
        <Target name="BatchToProcess" />
      </OperationReturnValues>
    </Operation>
    <Operation name="UpdateUsageMonitoringSummaries">
      <OperationSpec>
        <Description>Group usage monitoring to hourly and daily</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Owner whose usage monitoring is to be updated" state="implemented" />
        <Parameter name="AmountOfDays" dataType="int" designDesc="How many days to include from history" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="SourceItems" dataType="UsageMonitorItem[]" designDesc="SourceItems from day range" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="AmountOfDays" />
          </TargetDefinition>
          <MethodExecute name="CreateUsageMonitoringSummaries" designDesc="Create usage monitoring summaries for 5 minute, 1 hour and 1 day intervals" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="AmountOfDays" />
            <Target name="SourceItems" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="UpdateUsageMonitoringItems">
      <OperationSpec>
        <Description>Update usage monitoring of an owner</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Owner whose usage monitoring is to be updated" state="implemented" />
        <Parameter name="MonitoringItemTimeSpanInMinutes" dataType="int" designDesc="Monitoring item timespan in minutes (more than 1 interval in one item)" state="implemented" />
        <Parameter name="MonitoringIntervalInMinutes" dataType="int" designDesc="Monitoring interval in minutes" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="ValidateEqualSplitOfIntervalsInTimeSpan" designDesc="Validate that monitoring timespan divides equally to interval" state="implemented">
            <Parameter name="MonitoringItemTimeSpanInMinutes" />
            <Parameter name="MonitoringIntervalInMinutes" />
          </MethodExecute>
          <TargetDefinition name="CurrentMonitoringItems" dataType="Microsoft.WindowsAzure.Storage.Blob.CloudBlockBlob[]" designDesc="Current monitoring item entries" state="implemented">
            <Parameter name="Owner" />
          </TargetDefinition>
          <TargetDefinition name="EndingTimeOfCurrentItems" dataType="DateTime" designDesc="Starting time of new monitoring item(s)" state="implemented">
            <Target name="CurrentMonitoringItems" />
          </TargetDefinition>
          <TargetDefinition name="NewResourceUsageBlobs" dataType="Microsoft.WindowsAzure.Storage.Blob.CloudBlockBlob[]" designDesc="Resource usage collections after last monitoring item" state="implemented">
            <Parameter name="Owner" />
            <Target name="EndingTimeOfCurrentItems" />
          </TargetDefinition>
          <TargetDefinition name="StartingTimeOfNewItems" dataType="DateTime" designDesc="Ending time of complete monitoring item(s). Ensuring that resource records go beyond this time interval." state="implemented">
            <Parameter name="MonitoringItemTimeSpanInMinutes" />
            <Target name="EndingTimeOfCurrentItems" />
            <Target name="NewResourceUsageBlobs" />
          </TargetDefinition>
          <TargetDefinition name="EndingTimeOfNewItems" dataType="DateTime" designDesc="Ending time of complete monitoring item(s). Ensuring that resource records go beyond this time interval." state="implemented">
            <Parameter name="MonitoringItemTimeSpanInMinutes" />
            <Target name="StartingTimeOfNewItems" />
            <Target name="NewResourceUsageBlobs" />
          </TargetDefinition>
          <TargetDefinition name="ResourcesToIncludeInMonitoring" dataType="RequestResourceUsageCollection[]" designDesc="Resources to include in monitoring" state="implemented">
            <Target name="NewResourceUsageBlobs" />
            <Target name="EndingTimeOfNewItems" />
          </TargetDefinition>
          <TargetDefinition name="NewMonitoringItems" dataType="UsageMonitorItem[]" designDesc="New monitoring items. Empty and to be populated." state="implemented">
            <Parameter name="Owner" />
            <Parameter name="MonitoringItemTimeSpanInMinutes" />
            <Parameter name="MonitoringIntervalInMinutes" />
            <Target name="StartingTimeOfNewItems" />
            <Target name="EndingTimeOfNewItems" />
          </TargetDefinition>
          <MethodExecute name="PopulateMonitoringItems" designDesc="Populate monitoring items. Inclusive start time, exclusive end time." state="implemented">
            <Target name="ResourcesToIncludeInMonitoring" />
            <Target name="NewMonitoringItems" />
          </MethodExecute>
          <MethodExecute name="StoreObjects" designDesc="Store new objects" state="implemented">
            <Target name="NewMonitoringItems" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="PublishGroupToWww">
      <OperationSpec>
        <Description>Publish group content to Www-site</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Group as a owner. Used to retrieve required data to publish" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="GroupContainer" dataType="AaltoGlobalImpact.OIP.GroupContainer" designDesc="Group container of the group" state="implemented">
            <Parameter name="Owner" />
          </TargetDefinition>
          <TargetDefinition name="TargetContainerName" dataType="string" designDesc="Target container name" state="implemented">
            <Target name="GroupContainer" />
          </TargetDefinition>
          <TargetDefinition name="TargetContainerOwnerString" dataType="string" designDesc="GroupID of targetcontainer owner" state="implemented">
            <Target name="TargetContainerName" />
          </TargetDefinition>
          <MethodExecute name="ValidatePublishParameters" designDesc="Validate publish pre-requisites and parameters" state="implemented">
            <Parameter name="Owner" />
            <Target name="TargetContainerOwnerString" />
          </MethodExecute>
          <MethodExecute name="PublishWithWorker" designDesc="Publish website with worker call" state="implemented">
            <Parameter name="Owner" />
            <Target name="TargetContainerName" />
            <Target name="TargetContainerOwnerString" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="CreateOrUpdateCustomUI">
      <OperationSpec>
        <Description>
            Create custom web UI from given package and name.
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Group for whom to create the custom UI" state="implemented" />
        <Parameter name="CustomUIName" dataType="string" designDesc="Custom UI name" state="implemented" />
        <Parameter name="ZipArchiveStream" dataType="Stream" designDesc="Zip archive stream" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="GroupContainer" dataType="AaltoGlobalImpact.OIP.GroupContainer" designDesc="Group container to store the custom UI info" state="implemented">
            <Parameter name="Owner" />
          </TargetDefinition>
          <MethodExecute name="ValidateCustomUIName" designDesc="Validate CustomUI name to be valid. Allow only alphanumeric characters." state="implemented">
            <Parameter name="CustomUIName" />
          </MethodExecute>
          <TargetDefinition name="CustomUIFolder" dataType="string" designDesc="CustomUI folder prefix with trailing /" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="CustomUIName" />
          </TargetDefinition>
          <MethodExecute name="SetCustomUIName" designDesc="Set custom UI name within the list of custom UIs" state="implemented">
            <Parameter name="CustomUIName" />
            <Target name="GroupContainer" />
          </MethodExecute>
          <MethodExecute name="CopyUIContentsFromZipArchive" designDesc="Copy UI contents from zip archive. Replace existing and delete old files." state="implemented">
            <Parameter name="ZipArchiveStream" />
            <Target name="CustomUIFolder" />
          </MethodExecute>
          <MethodExecute name="StoreObject" designDesc="Store modified object" state="implemented">
            <Target name="GroupContainer" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="DeleteCustomUI">
      <OperationSpec>
        <Description>
            Delete custom web UI that matches the given name
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Group for whom to create the custom UI" state="implemented" />
        <Parameter name="CustomUIName" dataType="string" designDesc="Custom UI name" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="GroupContainer" dataType="AaltoGlobalImpact.OIP.GroupContainer" designDesc="Group container to store the custom UI info" state="implemented">
            <Parameter name="Owner" />
          </TargetDefinition>
          <TargetDefinition name="CustomUIFolder" dataType="string" designDesc="CustomUI folder prefix with trailing /" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="CustomUIName" />
          </TargetDefinition>
          <MethodExecute name="RemoveCustomUIName" designDesc="Remove custom UI name within the list of custom UIs" state="implemented">
            <Parameter name="CustomUIName" />
            <Target name="GroupContainer" />
          </MethodExecute>
          <MethodExecute name="RemoveCustomUIContents" designDesc="Remove UI contents from custom ui folder" state="implemented">
            <Target name="CustomUIFolder" />
          </MethodExecute>
          <MethodExecute name="StoreObject" designDesc="Store modified object" state="implemented">
            <Target name="GroupContainer" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="ExportOwnerContentToZip">
      <OperationSpec>
        <Description>Export Owner content to zip. Excluding system/core namespaces.</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Owner from whom to export." state="implemented" />
        <Parameter name="PackageRootFolder" dataType="string" designDesc="Root folder to package from the group root." state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="IncludedFolders" dataType="string[]" designDesc="Package included folders. Filtered by SystemSupport namespace restrictions." state="implemented">
            <Parameter name="Owner" />
            <Parameter name="PackageRootFolder" />
          </TargetDefinition>
          <OperationExecute name="PackageOwnerContentToZip" targetOperationName="PackageOwnerContent" designDesc="Package group current content" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="PackageRootFolder" />
            <Target name="IncludedFolders" />
            <ReturnValue name="ContentPackageObject" dataType="ContentPackage" designDesc="Content package object created" state="implemented" />
          </OperationExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="ContentPackageID" dataType="string" designDesc="Content package ID of the zip package" state="implemented" />
        <Target name="PackageOwnerContentToZipOutput" />
      </OperationReturnValues>
    </Operation>
    <Operation name="PackageOwnerContent">
      <OperationSpec>
        <Description>Package group content to zip from given group location</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Group for whom to create the custom UI" state="implemented" />
        <Parameter name="PackageType" dataType="string" designDesc="Content package type" state="implemented" />
        <Parameter name="PackageName" dataType="string" designDesc="Content package name" state="implemented" />
        <Parameter name="Description" dataType="string" designDesc="Content package description" state="implemented" />
        <Parameter name="PackageRootFolder" dataType="string" designDesc="Root folder to package from the group root." state="implemented" />
        <Parameter name="IncludedFolders" dataType="string[]" designDesc="Folders to include in the package" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="ContentPackageObject" dataType="ContentPackage" designDesc="Create content package information object" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="PackageType" />
            <Parameter name="PackageName" />
            <Parameter name="Description" />
            <Parameter name="PackageRootFolder" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store content package object" state="implemented">
            <Target name="ContentPackageObject" />
          </MethodExecute>
          <TargetDefinition name="ArchiveBlob" dataType="Microsoft.WindowsAzure.Storage.Blob.CloudBlockBlob" designDesc="Initiate archive blob for zip block updates. Same ID, same location, .zip extension" state="implemented">
            <Target name="ContentPackageObject" />
          </TargetDefinition>
          <TargetDefinition name="ArchiveSourceBlobs" dataType="Microsoft.WindowsAzure.Storage.Blob.CloudBlockBlob[]" designDesc="Source blobs for archiving" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="PackageRootFolder" />
            <Parameter name="IncludedFolders" />
          </TargetDefinition>
          <MethodExecute name="CreateZipPackageContent" designDesc="Create zip package to match the content object" state="implemented">
            <Parameter name="IncludedFolders" />
            <Target name="ContentPackageObject" />
            <Target name="ArchiveSourceBlobs" />
            <Target name="ArchiveBlob" />
            <ReturnValue name="UploadedBlockList" dataType="string[]" designDesc="Uploaded block ID list" state="implemented" />
          </MethodExecute>
          <MethodExecute name="CommitArchiveBlob" designDesc="Commit archive blob" state="implemented">
            <Target name="ArchiveBlob" />
            <Target name="CreateZipPackageContentOutput" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="ContentPackage" dataType="ContentPackage" designDesc="Content package object created and packed" state="implemented" />
        <Target name="ContentPackageObject" />
      </OperationReturnValues>
    </Operation>
    <Operation name="DeviceSyncFullAccountOperation">
      <OperationSpec>
        <Description>Device full account sync operation. Streams are encryption wrapped already, the operation will GZip compress handle them as well.</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="InputStream" dataType="System.IO.Stream" designDesc="Input stream for operation" state="implemented" />
        <Parameter name="OutputStream" dataType="System.IO.Stream" designDesc="Input stream for operation" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="SyncRequest" dataType="TheBall.Support.VirtualStorage.ContentSyncRequest" designDesc="Content sync request data" state="implemented">
            <Parameter name="InputStream" />
          </TargetDefinition>
          <TargetDefinition name="AccountOwner" dataType="AaltoGlobalImpact.OIP.TBAccount" designDesc="Requesting account " state="implemented" />
          <TargetDefinition name="GroupOwners" dataType="IContainerOwner[]" designDesc="Account's groups" state="implemented">
            <Target name="AccountOwner" />
          </TargetDefinition>
          <TargetDefinition name="SyncResponse" dataType="TheBall.Support.VirtualStorage.ContentSyncResponse" designDesc="Sync response based on request and data" state="implemented">
            <Target name="SyncRequest" />
            <Target name="AccountOwner" />
            <Target name="GroupOwners" />
          </TargetDefinition>
          <MethodExecute name="WriteResponseToStream" designDesc="Write full response to stream" state="implemented">
            <Parameter name="OutputStream" />
            <Target name="SyncResponse" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="RemoteDeviceCoreOperation">
      <OperationSpec>
        <Description>Remote device core operation for primitive ops to deal with device-to-device actions</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="InputStream" dataType="System.IO.Stream" designDesc="Input stream for operation" state="implemented" />
        <Parameter name="OutputStream" dataType="System.IO.Stream" designDesc="Input stream for operation" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="DeviceOperationData" dataType="INT.DeviceOperationData" designDesc="Device operation data from input stream" state="implemented">
            <Parameter name="InputStream" />
          </TargetDefinition>
          <TargetDefinition name="CurrentDevice" dataType="DeviceMembership" designDesc="Current executing device (obtained through InformationContext.CurrentDevice" state="implemented" />
          <MethodExecute name="PerformOperation" designDesc="Perform specific operation based on Device Operation Data" state="implemented">
            <Target name="CurrentDevice" />
            <Target name="DeviceOperationData" />
          </MethodExecute>
          <MethodExecute name="SerializeDeviceOperationDataToOutput" designDesc="Serialize result to output" state="implemented">
            <Parameter name="OutputStream" />
            <Target name="DeviceOperationData" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="SyncCopyContentToDeviceTarget">
      <OperationSpec>
        <Description>Sync-copy content to device target. Compare both sides with MD5, delete files that do not exist in copy source.</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="AuthenticatedAsActiveDeviceID" dataType="string" designDesc="Authenticated as device source for copying" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="AuthenticatedAsActiveDevice" dataType="AuthenticatedAsActiveDevice" designDesc="AuthenticatedAsActiveDevice object" state="implemented">
            <Parameter name="AuthenticatedAsActiveDeviceID" />
          </TargetDefinition>
          <TargetDefinition name="ContentRootLocation" dataType="string" designDesc="Content root location" state="implemented">
            <Target name="AuthenticatedAsActiveDevice" />
          </TargetDefinition>
          <TargetDefinition name="ThisSideContentMD5List" dataType="INT.ContentItemLocationWithMD5[]" designDesc="This side content MD5 list" state="implemented">
            <Target name="ContentRootLocation" />
          </TargetDefinition>
          <MethodExecute name="CallPrepareTargetAndListItemsToCopy" designDesc="Call cleanup and retrieve list to copy from target device" state="implemented">
            <Target name="AuthenticatedAsActiveDevice" />
            <Target name="ThisSideContentMD5List" />
            <ReturnValue name="ItemsToCopy" dataType="INT.ContentItemLocationWithMD5[]" designDesc="Items to copy to target" state="implemented" />
            <ReturnValue name="ItemsDeleted" dataType="INT.ContentItemLocationWithMD5[]" designDesc="Items deleted on target" state="implemented" />
          </MethodExecute>
          <MethodExecute name="CopyItemsToCopyToTargetDevice" designDesc="Copy items to copy to target device" state="implemented">
            <Target name="AuthenticatedAsActiveDevice" />
            <Target name="CallPrepareTargetAndListItemsToCopyOutput" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="CopiedItems" dataType="INT.ContentItemLocationWithMD5[]" designDesc="Copied items" state="implemented" />
        <ReturnValue name="DeletedItems" dataType="INT.ContentItemLocationWithMD5[]" designDesc="Deleted items" state="implemented" />
        <Target name="CallPrepareTargetAndListItemsToCopyOutput" />
      </OperationReturnValues>
    </Operation>
    <Operation name="MergeAccountsDestructively">
      <OperationSpec>
        <Description>
            Merges two accounts into one and destroys the leftover. Parameters state these as "PrimaryAccountToStay" and "AccountToMergeAndDestroy"
          </Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="PrimaryAccountToStayID" dataType="string" designDesc="Primary account that is going to stay after the merge" state="implemented" />
        <Parameter name="AccountToBeMergedAndDestroyedID" dataType="string" designDesc="Account to be merged and destroyed" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="PrimaryAccountToStay" dataType="AaltoGlobalImpact.OIP.TBRAccountRoot" designDesc="Primary account root" state="implemented">
            <Parameter name="PrimaryAccountToStayID" />
          </TargetDefinition>
          <TargetDefinition name="AccountToBeMerged" dataType="AaltoGlobalImpact.OIP.TBRAccountRoot" designDesc="Account to be merged" state="implemented">
            <Parameter name="AccountToBeMergedAndDestroyedID" />
          </TargetDefinition>
          <TargetDefinition name="GroupAccessToBeMerged" dataType="AaltoGlobalImpact.OIP.TBAccountCollaborationGroup[]" designDesc="Group access from account, that's being merged - not initiator roles" state="implemented">
            <Target name="AccountToBeMerged" />
          </TargetDefinition>
          <TargetDefinition name="GroupInitiatorAccessToBeTransfered" dataType="AaltoGlobalImpact.OIP.TBAccountCollaborationGroup[]" designDesc="Group access from account, that's being merged - not initiator roles" state="implemented">
            <Target name="AccountToBeMerged" />
          </TargetDefinition>
          <TargetDefinition name="EmailAddressesToBeMerged" dataType="AaltoGlobalImpact.OIP.TBEmail[]" designDesc="Email addresses from account to be merged" state="implemented">
            <Target name="AccountToBeMerged" />
          </TargetDefinition>
          <TargetDefinition name="LoginAccessToBeMerged" dataType="AaltoGlobalImpact.OIP.TBLoginInfo[]" designDesc="Login information from access to be merged" state="implemented">
            <Target name="AccountToBeMerged" />
          </TargetDefinition>
          <MethodExecute name="ValidateAccountToBeMerged" designDesc="Validate account to be merged not to contain groups or emails (for the time being)" state="implemented">
            <Target name="GroupAccessToBeMerged" />
            <Target name="GroupInitiatorAccessToBeTransfered" />
            <Target name="EmailAddressesToBeMerged" />
          </MethodExecute>
          <MethodExecute name="RemoveAccountToBeMergedFromAllGroups" designDesc="Remove account to be merged from all of its groups" state="implemented">
            <Target name="AccountToBeMerged" />
            <Target name="GroupAccessToBeMerged" />
          </MethodExecute>
          <MethodExecute name="RemoveEmailAddressesFromAccountToBeMerged" designDesc="Remove all email addresses from account to be merged" state="implemented">
            <Target name="AccountToBeMerged" />
          </MethodExecute>
          <MethodExecute name="RemoveLoginsFromAccountToBeMerged" designDesc="Remove all login accounts from account to be merged" state="implemented">
            <Target name="AccountToBeMerged" />
          </MethodExecute>
          <MethodExecute name="AddLoginsToPrimaryAccount" designDesc="Add logins to new primary account" state="implemented">
            <Target name="PrimaryAccountToStay" />
            <Target name="LoginAccessToBeMerged" />
          </MethodExecute>
          <MethodExecute name="AddEmailAddressesToPrimaryAccount" designDesc="Add email addresses to new primary account" state="implemented">
            <Target name="PrimaryAccountToStay" />
            <Target name="EmailAddressesToBeMerged" />
          </MethodExecute>
          <MethodExecute name="StorePrimaryAccount" designDesc="Store primary account object" state="implemented">
            <Target name="PrimaryAccountToStay" />
          </MethodExecute>
          <MethodExecute name="CallRefreshAccountRootToReferences" designDesc="Fix account root of primary account" state="implemented">
            <Parameter name="PrimaryAccountToStayID" />
          </MethodExecute>
          <MethodExecute name="AddPrimaryAccountToAllGroupsWhereItsMissing" designDesc="All primary account to all groups where its missing" state="implemented">
            <Target name="PrimaryAccountToStay" />
            <Target name="GroupAccessToBeMerged" />
          </MethodExecute>
          <MethodExecute name="TransferGroupInitiatorRights" designDesc="Transfer group initiator rights" state="implemented">
            <Parameter name="PrimaryAccountToStayID" />
            <Parameter name="AccountToBeMergedAndDestroyedID" />
            <Target name="GroupInitiatorAccessToBeTransfered" />
          </MethodExecute>
          <MethodExecute name="UpdateAccountGroupLogins" designDesc="Refresh account group relations" state="implemented">
            <Parameter name="PrimaryAccountToStayID" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="TransferGroupInitiator">
      <OperationSpec>
        <Description>Change group initiator from one account to another</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="GroupID" dataType="string" designDesc="Group ID whose initiatorship is to be transfered" state="implemented" />
        <Parameter name="OldInitiatorAccountID" dataType="string" designDesc="Old initiator account ID" state="implemented" />
        <Parameter name="NewInitiatorAccountID" dataType="string" designDesc="New initiator account ID" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="AddNewInitiatorToGroup" designDesc="Add new initiator to group" state="implemented">
            <Parameter name="GroupID" />
            <Parameter name="NewInitiatorAccountID" />
          </MethodExecute>
          <MethodExecute name="RemoveOldInitiatorFromGroup" designDesc="Remove old initiator from group" state="implemented">
            <Parameter name="GroupID" />
            <Parameter name="OldInitiatorAccountID" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="InitiateAccountMergeFromEmail">
      <OperationSpec>
        <Description>Initiate account merger from email re-registration.</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="EmailAddress" dataType="string" designDesc="Email address that the merge is based on" state="implemented" />
        <Parameter name="CurrentAccountID" dataType="string" designDesc="Current account ID that is submitting the email" state="implemented" />
        <Parameter name="RedirectUrlAfterValidation" dataType="string" designDesc="Redirect url after email validation" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <MethodExecute name="ValidateExistingEmail" designDesc="Validate that the email to add is already registered" state="implemented">
            <Parameter name="EmailAddress" />
          </MethodExecute>
          <TargetDefinition name="AccountToMergeToID" dataType="string" designDesc="Original account to be merged to" state="implemented">
            <Parameter name="EmailAddress" />
          </TargetDefinition>
          <MethodExecute name="ValidateAccountNotTheSame" designDesc="Validate that the account initiating the merge is not the same as the target" state="implemented">
            <Parameter name="CurrentAccountID" />
            <Target name="AccountToMergeToID" />
          </MethodExecute>
          <TargetDefinition name="MergeAccountEmailConfirmation" dataType="AaltoGlobalImpact.OIP.TBEmailValidation" designDesc="Initiate merge account if current account ID and account to merge to ID are different" state="implemented">
            <Parameter name="CurrentAccountID" />
            <Parameter name="EmailAddress" />
            <Parameter name="RedirectUrlAfterValidation" />
            <Target name="AccountToMergeToID" />
          </TargetDefinition>
          <MethodExecute name="StoreObject" designDesc="Store object" state="implemented">
            <Target name="MergeAccountEmailConfirmation" />
          </MethodExecute>
          <MethodExecute name="SendConfirmationEmail" designDesc="Send confirmation email" state="implemented">
            <Target name="MergeAccountEmailConfirmation" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="ConfirmAccountMergeFromEmail">
      <OperationSpec>
        <Description>Confirms account merge from email confirmation</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="CurrentAccountID" dataType="string" designDesc="Current account ID" state="implemented" />
        <Parameter name="EmailConfirmation" dataType="AaltoGlobalImpact.OIP.TBEmailValidation" designDesc="Email validation object" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="MergeAccountConfirmation" dataType="AaltoGlobalImpact.OIP.TBMergeAccountConfirmation" designDesc="Merge account confirmation" state="implemented">
            <Parameter name="EmailConfirmation" />
          </TargetDefinition>
          <MethodExecute name="ValidateCurrentAccountAsMergingActor" designDesc="Validate that current account ID is indeed the account to be merged owner" state="implemented">
            <Parameter name="CurrentAccountID" />
            <Target name="MergeAccountConfirmation" />
          </MethodExecute>
          <MethodExecute name="PerformAccountMerge" designDesc="Perform account merge with source and target IDs" state="implemented">
            <Target name="MergeAccountConfirmation" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
    <Operation name="GetOwnerSemanticDomains">
      <OperationSpec>
        <Description>Retrieve list of semantic domains based on owner storage folders. Identify domains containing . and two parts in their name</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="SkipSystemDomains" dataType="bool" designDesc="Skips system domains" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="OwnerDomains" asyncSupportMode="AsyncOnly" dataType="string[]" designDesc="Owner domains optionally filtered from system domains" state="implemented">
            <Parameter name="SkipSystemDomains" />
          </TargetDefinition>
        </SequentialExecution>
      </Execution>
      <OperationReturnValues>
        <ReturnValue name="OwnerSemanticDomains" dataType="string[]" designDesc="Owner domains" state="implemented" />
        <Target name="OwnerDomains" />
      </OperationReturnValues>
    </Operation>
    <Operation name="UpdateOwnerDomainObjectsInSQLiteStorage">
      <OperationSpec>
        <Description>Update owner domain objects in owner's SQLite storage, located within "tbcore" Azure file share</Description>
      </OperationSpec>
      <Parameters>
        <Parameter name="Owner" dataType="IContainerOwner" designDesc="Owner whose objects are to be updated" state="implemented" />
        <Parameter name="SemanticDomain" dataType="string" designDesc="Semantic domain of objects to be updated" state="implemented" />
      </Parameters>
      <Execution>
        <SequentialExecution>
          <TargetDefinition name="SQLiteDBLocationDirectory" dataType="string" designDesc="SQLite database location based on owner and semantic domain." state="implemented">
            <Parameter name="Owner" />
          </TargetDefinition>
          <MethodExecute name="CreateDBLocationDirectoryIfMissing" designDesc="Create database directory if missing" state="implemented">
            <Target name="SQLiteDBLocationDirectory" />
          </MethodExecute>
          <TargetDefinition name="DataContextFullTypeName" dataType="string" designDesc="SQLite data context full type name" state="implemented">
            <Parameter name="SemanticDomain" />
          </TargetDefinition>
          <TargetDefinition name="DataContextType" dataType="System.Type" designDesc="SQLite data context type object" state="implemented">
            <Target name="DataContextFullTypeName" />
          </TargetDefinition>
          <TargetDefinition name="DatabaseAttachOrCreateMethodName" dataType="string" designDesc="Database attach or create method name" state="implemented" />
          <TargetDefinition name="SQLiteDBLocationFileName" dataType="string" designDesc="SQLite full database path based on semantic domain" state="implemented">
            <Parameter name="SemanticDomain" />
            <Target name="SQLiteDBLocationDirectory" />
          </TargetDefinition>
          <TargetDefinition name="OwnerRootPath" dataType="string" designDesc="Absolute cloud storage root path to owner root" state="implemented">
            <Parameter name="Owner" />
          </TargetDefinition>
          <TargetDefinition name="BlobsToSync" asyncSupportMode="Both" dataType="Microsoft.WindowsAzure.Storage.Blob.CloudBlockBlob[]" designDesc="Blob listings to sync" state="implemented">
            <Parameter name="Owner" />
            <Parameter name="SemanticDomain" />
          </TargetDefinition>
          <MethodExecute name="PerformSyncing" asyncSupportMode="Both" designDesc="Perform actual syncing" state="implemented">
            <Target name="DataContextType" />
            <Target name="DatabaseAttachOrCreateMethodName" />
            <Target name="SQLiteDBLocationFileName" />
            <Target name="OwnerRootPath" />
            <Target name="BlobsToSync" />
          </MethodExecute>
        </SequentialExecution>
      </Execution>
    </Operation>
  </Operations>
</OperationAbstraction>